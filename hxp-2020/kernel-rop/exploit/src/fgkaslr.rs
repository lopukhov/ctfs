use std::{
    fs::File,
    io::{BufRead, BufReader},
    str::FromStr,
};

use smol_str::SmolStr;

pub struct KAllSyms {
    reader: BufReader<File>,
    line: String,
}

impl KAllSyms {
    pub fn new(path: &str) -> Result<Self, std::io::Error> {
        let fd = File::open(path)?;
        Ok(Self {
            reader: BufReader::new(fd),
            line: String::new(),
        })
    }
}

impl Iterator for KAllSyms {
    type Item = KSymbol;

    fn next(&mut self) -> Option<Self::Item> {
        self.line.clear();
        match self
            .reader
            .read_line(&mut self.line)
            .expect("/proc/kallsyms is valid utf8")
        {
            0 => None,
            _ => Some(
                self.line
                    .trim()
                    .parse()
                    .expect("entries should not be malformed"),
            ),
        }
    }
}

#[derive(Debug)]
pub struct ParseError;

/// An entry in kallsyms
#[derive(Debug)]
pub struct KSymbol {
    pub address: usize,
    pub t: Type,
    pub name: SmolStr,
}

impl FromStr for KSymbol {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split_whitespace();
        let offset = parts.next().ok_or(ParseError)?;
        let typ = parts.next().ok_or(ParseError)?;
        let symb = parts.next().ok_or(ParseError)?;

        Ok(KSymbol {
            address: usize::from_str_radix(offset, 16).map_err(|_| ParseError)?,
            t: typ.parse()?,
            name: SmolStr::new(symb),
        })
    }
}

/// From `man nm`:
///
/// "A" The symbol's value is absolute, and will not be changed by further linking.
///
/// "B"
/// "b" The symbol is in the BSS data section.  This section typically contains zero-initialized or uninitialized data, although the exact behavior is system dependent.
///
/// "C"
/// "c" The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear with the same name.  If the symbol is defined anywhere, the common
///    symbols are treated as undefined references.  The lower case c character is used when the symbol is in a special section for small commons.
///
/// "D"
/// "d" The symbol is in the initialized data section.
///
/// "G"
/// "g" The symbol is in an initialized data section for small objects.  Some object file formats permit more efficient access to small data objects, such as a global int variable as
///    opposed to a large global array.
///
/// "i" For PE format files this indicates that the symbol is in a section specific to the implementation of DLLs.
///
///    For ELF format files this indicates that the symbol is an indirect function.  This is a GNU extension to the standard set of ELF symbol types.  It indicates a symbol which if
///    referenced by a relocation does not evaluate to its address, but instead must be invoked at runtime.  The runtime execution will then return the value to be used in the relocation.
///
///    Note - the actual symbols display for GNU indirect symbols is controlled by the --ifunc-chars command line option.  If this option has been provided then the first character in the
///    string will be used for global indirect function symbols.  If the string contains a second character then that will be used for local indirect function symbols.
///
/// "I" The symbol is an indirect reference to another symbol.
///
/// "N" The symbol is a debugging symbol.
///
/// "n" The symbol is in the read-only data section.
///
/// "p" The symbol is in a stack unwind section.
///
/// "R"
/// "r" The symbol is in a read only data section.
///
/// "S"
/// "s" The symbol is in an uninitialized or zero-initialized data section for small objects.
///
/// "T"
/// "t" The symbol is in the text (code) section.
///
/// "U" The symbol is undefined.
///
/// "u" The symbol is a unique global symbol.  This is a GNU extension to the standard set of ELF symbol bindings.  For such a symbol the dynamic linker will make sure that in the entire
///    process there is just one symbol with this name and type in use.
///
/// "V"
/// "v" The symbol is a weak object.  When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is
///    linked and the symbol is not defined, the value of the weak symbol becomes zero with no error.  On some systems, uppercase indicates that a default value has been specified.
///
/// "W"
/// "w" The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.  When a weak defined symbol is linked with a normal defined symbol, the normal defined
///    symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the symbol is determined in a system-specific manner without
///    error.  On some systems, uppercase indicates that a default value has been specified.
///
/// "-" The symbol is a stabs symbol in an a.out object file.  In this case, the next values printed are the stabs other field, the stabs desc field, and the stab type.  Stabs symbols are
///    used to hold debugging information.
///
/// "?" The symbol type is unknown, or object file format specific.
#[allow(non_camel_case_types)]
#[derive(Debug, PartialEq, PartialOrd)]
pub enum Type {
    A,
    a,
    B,
    C,
    D,
    G,
    i,
    I,
    N,
    n,
    p,
    R,
    S,
    T,
    U,
    u,
    V,
    W,
    Stabs,
    Unknown,
}

impl FromStr for Type {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "A" => Ok(Type::A),
            "a" => Ok(Type::a),
            "B" | "b" => Ok(Type::B),
            "C" | "c" => Ok(Type::C),
            "D" | "d" => Ok(Type::D),
            "G" | "g" => Ok(Type::G),
            "i" => Ok(Type::i),
            "I" => Ok(Type::I),
            "N" => Ok(Type::N),
            "n" => Ok(Type::n),
            "p" => Ok(Type::p),
            "R" | "r" => Ok(Type::R),
            "S" | "s" => Ok(Type::S),
            "T" | "t" => Ok(Type::T),
            "U" => Ok(Type::U),
            "u" => Ok(Type::u),
            "V" | "v" => Ok(Type::V),
            "W" | "w" => Ok(Type::W),
            "-" => Ok(Type::Stabs),
            "?" => Ok(Type::Unknown),
            _ => Err(ParseError),
        }
    }
}
